# I2C(origine)(未含tick)

## I2C_control

```verilog
// Copyright (C) 2017  Intel Corporation. All rights reserved.
// Your use of Intel Corporation's design tools, logic functions 
// and other software and tools, and its AMPP partner logic 
// functions, and any output files from any of the foregoing 
// (including device programming or simulation files), and any 
// associated documentation or information are expressly subject 
// to the terms and conditions of the Intel Program License 
// Subscription Agreement, the Intel Quartus Prime License Agreement,
// the Intel FPGA IP License Agreement, or other applicable license
// agreement, including, without limitation, that your use is for
// the sole purpose of programming logic devices manufactured by
// Intel and sold by Intel or its authorized distributors.  Please
// refer to the applicable agreement for further details.

// Generated by Quartus Prime Version 17.1.0 Build 590 10/25/2017 SJ Lite Edition
// Created on Sun Mar 28 23:13:49 2021

// synthesis message_off 10175

`timescale 1ns/1ns

module I2C_control (
    reset,CLK,GO,bitcount,
    SCLK_Temp,bitcountEN,rstbitcount,LDEN,ldnACK1,ldnACK2,ldnACK3,rstACK,SHEN,SDO,SCLK);

    input reset;
    input CLK;
    input GO;
    input [4:0] bitcount;
    tri0 reset;
    tri0 GO;
    tri0 [4:0] bitcount;
    output SCLK_Temp;
    output bitcountEN;
    output rstbitcount;
    output LDEN;
    output ldnACK1;
    output ldnACK2;
    output ldnACK3;
    output rstACK;
    output SHEN;
    output SDO;
	 output SCLK;//add
    reg SCLK_Temp;
    reg bitcountEN;
    reg rstbitcount;
    reg LDEN;
    reg ldnACK1;
    reg ldnACK2;
    reg ldnACK3;
    reg rstACK;
    reg SHEN;
    reg SDO;
    reg [7:0] fstate;
    reg [7:0] reg_fstate;
    parameter X_GO=0,X_START=1,X_WAIT=2,X_STOP=3,X_FINAL=4,X_END=5,X_SHIFT=6,X_IDLE=7;
	 assign SCLK = (SHEN)?(~CLK):(SCLK_Temp);
    always @(posedge CLK or posedge reset)
    begin
        if (reset) begin
            fstate <= X_IDLE;
        end
        else begin
            fstate <= reg_fstate;
        end
    end

    always @(fstate or GO or bitcount)
    begin
        SCLK_Temp <= 1'b0;
        bitcountEN <= 1'b0;
        rstbitcount <= 1'b0;
        LDEN <= 1'b0;
        ldnACK1 <= 1'b0;
        ldnACK2 <= 1'b0;
        ldnACK3 <= 1'b0;
        rstACK <= 1'b0;
        SHEN <= 1'b0;
        SDO <= 1'b0;
        case (fstate)
            X_GO: begin
                reg_fstate <= X_START;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b1;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b1;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_START: begin
                reg_fstate <= X_WAIT;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b0;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_WAIT: begin
                reg_fstate <= X_SHIFT;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b0;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_STOP: begin
                reg_fstate <= X_FINAL;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b0;

                SDO <= 1'b0;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_FINAL: begin
                reg_fstate <= X_END;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b0;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_END: begin
                reg_fstate <= X_IDLE;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b1;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b1;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            X_SHIFT: begin
                if ((bitcount[4:0] == 5'b11010))
                    reg_fstate <= X_STOP;
                else if ((bitcount[4:0] < 5'b11010))
                    reg_fstate <= X_SHIFT;
                // Inserting 'else' block to prevent latch inference
                else
                    reg_fstate <= X_SHIFT;

                if ((bitcount[4:0] != 5'b10001))
                    ldnACK2 <= 1'b0;
                else if ((bitcount[4:0] == 5'b10001))
                    ldnACK2 <= 1'b1;
                // Inserting 'else' block to prevent latch inference
                else
                    ldnACK2 <= 1'b0;

                if ((bitcount[4:0] != 5'b11010))
                    ldnACK3 <= 1'b0;
                else if ((bitcount[4:0] == 5'b11010))
                    ldnACK3 <= 1'b1;
                // Inserting 'else' block to prevent latch inference
                else
                    ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b0;

                SDO <= 1'b1;

                bitcountEN <= 1'b1;

                if ((bitcount[4:0] != 5'b01000))
                    ldnACK1 <= 1'b0;
                else if ((bitcount[4:0] == 5'b01000))
                    ldnACK1 <= 1'b1;
                // Inserting 'else' block to prevent latch inference
                else
                    ldnACK1 <= 1'b0;

                SHEN <= 1'b1;

                if ((bitcount[4:0] < 5'b11010))
                    rstbitcount <= 1'b0;
                else if ((bitcount[4:0] == 5'b11010))
                    rstbitcount <= 1'b1;
                // Inserting 'else' block to prevent latch inference
                else
                    rstbitcount <= 1'b0;
            end
            X_IDLE: begin
                if (GO)
                    reg_fstate <= X_GO;
                else if (~(GO))
                    reg_fstate <= X_IDLE;
                // Inserting 'else' block to prevent latch inference
                else
                    reg_fstate <= X_IDLE;

                ldnACK2 <= 1'b0;

                ldnACK3 <= 1'b0;

                LDEN <= 1'b0;

                rstACK <= 1'b0;

                SCLK_Temp <= 1'b1;

                SDO <= 1'b1;

                bitcountEN <= 1'b0;

                ldnACK1 <= 1'b0;

                SHEN <= 1'b0;

                rstbitcount <= 1'b0;
            end
            default: begin
                SCLK_Temp <= 1'bx;
                bitcountEN <= 1'bx;
                rstbitcount <= 1'bx;
                LDEN <= 1'bx;
                ldnACK1 <= 1'bx;
                ldnACK2 <= 1'bx;
                ldnACK3 <= 1'bx;
                rstACK <= 1'bx;
                SHEN <= 1'bx;
                SDO <= 1'bx;
                $display ("Reach undefined state");
            end
        endcase
    end
endmodule // I2C_control
```

## TestBench

```verilog
`timescale 1ns/1ns
	module tb_I2C_control();
	reg reset;
   reg CLK;
   reg GO;
   reg [4:0]bitcount;
   wire SCLK_Temp;
   wire bitcountEN;
   wire rstbitcount;
   wire LDEN;
   wire ldnACK1;
   wire ldnACK2;
   wire ldnACK3;
   wire rstACK;
   wire SHEN;
   wire SDO;
	wire SCLK;//add
	
	I2C_control UUT(
		.reset(reset),
		.CLK(CLK),
		.GO(GO),
		.bitcount(bitcount),
		.SCLK_Temp(SCLK_Temp),
		.bitcountEN(bitcountEN),
		.rstbitcount(rstbitcount),
		.LDEN(LDEN),
		.ldnACK1(ldnACK1),
		.ldnACK2(ldnACK2),
		.ldnACK3(ldnACK3),
		.rstACK(rstACK),
		.SHEN(SHEN),
		.SDO(SDO),
		.SCLK(SCLK)
	);
	initial begin
		CLK = 1'b0;
	end
	always #50 CLK = ~CLK;
	initial begin
		reset = 1'b1;
		while(1)
		#100 reset = 1'b0;
	end
	initial begin
		GO = 1'b0;
		#100 GO = 1'b1;
		#100 GO = 1'b0;
	end
	initial begin
		bitcount = 5'd0;
		#550 bitcount = 5'd1;
		#100 bitcount = 5'd2;
		#100 bitcount = 5'd3;
		#100 bitcount = 5'd4;
		#100 bitcount = 5'd5;
		#100 bitcount = 5'd6;
		#100 bitcount = 5'd7;
		#100 bitcount = 5'd8;
		#100 bitcount = 5'd9;
		#100 bitcount = 5'd10;
		#100 bitcount = 5'd11;
		#100 bitcount = 5'd12;
		#100 bitcount = 5'd13;
		#100 bitcount = 5'd14;
		#100 bitcount = 5'd15;
		#100 bitcount = 5'd16;
		#100 bitcount = 5'd17;
		#100 bitcount = 5'd18;
		#100 bitcount = 5'd19;
		#100 bitcount = 5'd20;
		#100 bitcount = 5'd21;
		#100 bitcount = 5'd22;
		#100 bitcount = 5'd23;
		#100 bitcount = 5'd24;
		#100 bitcount = 5'd25;
		#100 bitcount = 5'd26;
		#1000 $finish;
	end
	endmodule
```

## Wave

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled.png](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled.png)

## Compilation Report

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%201.png](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%201.png)

## RTL Viewer

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%202.png](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%202.png)

## State Machine

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%203.png](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/Untitled%203.png)

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487613.jpg](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487613.jpg)

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487611.jpg](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487611.jpg)

![I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487610.jpg](I2C(origine)(%E6%9C%AA%E5%90%ABtick)%20aafd638963a34ac395389d731a90b9c8/S__7487610.jpg)